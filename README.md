# we-have-compiler-at-home

В этой задачке нужно вычислить значение выражения
(to evaluate expression).
Будете ли вы для этого использовать python или lua?
Нет!
Можно ли воспользоваться Си и просто его скомпилировать?
НЕТ!

В этой задачке мы отказываемся от излишеств.
Вам нужно пихать в процессор байтики голыми руками.


## armv7

Во всех других задачах на arm у нас aarch64.
Тут — armv7.


## Задача

Используя arm reference manual, научитесь кодировать инструкции.

Реализуйте функцию
```
int compile(const char *expression, const symbol_t **symbol_table, void *opcodes_out);
```

Функция должна распарсить выражение, записанное в `expression`,
понять, как его скомпилировать, и записать в `opcodes_out` функцию
в виде машинных инструкций совместимых с armv7, которая
посчитаeт значение.
Считайте, что `opcodes_out` выравнен.
Используйте A1 ARM encoding.

Основная программа выполнит вашы op-коды (вызовет функцию) и
сверит ответ.

По аргументам:
- возвращайте `0` если компиляция удалась
- `opcodes_out` — сюда вы записываете готовые op-код
  * память выделена щедро и с запасом; 4K байтиков вам хватит)
- `expression` — это строка с текстом (пример: `2+3*4`)
- `symbol_table` — массив с таблицей символов, которые используются в `expression`.
  * в `expression` могут использоваться переменные и функции
    + `2 + x12 * max(A, 2)`: тут `x12` — переменная, а `max` — функция
  * `sybmol_table` — NULL-terminated массив, в котором находятся связки `имя X адресс`
  * `имя` — Си-строка, валидное имя переменной / фукнции (regex: `[A-Za-z_][A-Za-z0-9_]*`), длинной до 256 символов
  * `адресс` — указатель на переменную / функцию, который связан с данным именем
  * когда вы встречаете переменную, надо (прям в op-кодах) разыменовать указатель на неё
  * когда вы встречаете функцию — вам надо её вызвать (прям в op-кодах)
  * подробнее про вызов функций в arm смотрите в application binary interface (ABI) внизу


## Ограничения

### ограничения на expression (мы — вам)

- встречаются только символы `+`, `-`, `*`, `(`, `)`, `_` (пробел), и числа
- унарного инкремента / декремента нету
- числа только целые, результат всегда только целый
- могут встретиться переменные и функции ТОЛЬКО из `symbol_table`
- все функции из `symbol_table` принимают не более 4-х аргументов и возврашают 16bit integer
  * передачу 5-и и более можно не реализовывать
- строка с выражением заканчивается `\0` (нулём)
  * всё что после — мусор, который нужно игнорировать
- на любом из шагов при вычислении результат будет вмещаться в 16bit (halfword)
- порядок операций стандартный
- валидировать expression на корректность не нужно, сосредоточтесь на success-сценариях
  * garbage in --> garbage out



### ограничения на решение (вы — нам)

- вам нужно разобраться, как кодируются команды
  * использовать "пачку" из готовых op-кодов нельзя
  * собирайте каждую команду ручками
  * если какой-то бит влияет на поведение команды — лучше задать этот бит явно
- вызывать компилятор и воровать у него ответ — нельзя)
- при парсинге схлопывать константы (`2 + 2 * 3` --> `8`) тоже нельзя)
  * выражение должно быть често посчитано в op-кодах
- вызывать lua (или любой другое скриптовый язык) и брать ответ у него — нельзя
- работать с переменными и функциями из `symbol_table` должны ваши op-коды
  * переменные нужно честно загружать перед каждым использованием
  * функции нужно честно вызывать
- to be continued...

## Примеры expression, которые могут встретится

- `2+5`
- `2+2*2`
- `    1 + (   1 +(1+1)  )`
- `2+2 * 3-1`


## А как тестировать?

### Makefile

В начале `Makefile` прописаны пути до компиляторов, sysroot и qemu.

Можно вызвать `make EXPRESSION='2+2*2' run` чтоб выполнить нужное тебе выражение.
Или `make EXPRESSION='2+2*2' run-gdb` чтоб можно было подключить отладчик.


Просто запуск `make` без аргументов запустит тесты из `test_simple.c`.


## Материалы

- [arm architecture reference manual armv7](https://developer.arm.com/documentation/ddi0406/latest/)
- [application binary interface](https://developer.arm.com/Architectures/Application%20Binary%20Interface)
- [кросскомпиляция (теория)](https://habr.com/ru/articles/319736/)
- [ссылка на компилятор](https://releases.linaro.org/components/toolchain/binaries/latest-7/) / или можете поставить через менеджер пакетов вашего дистрибутива
- [как запустить](https://azeria-labs.com/arm-on-x86-qemu-user/)
- [удалённая отладка](https://developers.redhat.com/blog/2015/04/28/remote-debugging-with-gdb)
- [отладка через qemu](https://qemu-project.gitlab.io/qemu/system/gdb.html) (по идее за вас всё настроено)
